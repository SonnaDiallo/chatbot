// // server.js - Version finale qui FONCTIONNE
// const express = require('express');
// const cors = require('cors');
// const mongoose = require('mongoose');
// const dotenv = require('dotenv');
// const path = require('path');

// // Chargement des variables d'environnement
// dotenv.config();

// const app = express();
// const PORT = process.env.PORT || 5000;

// // ‚ö†Ô∏è CORS DOIT √äTRE CONFIGUR√â EN PREMIER
// app.use(cors({
//   origin: '*', // Accepter toutes les origines pour le d√©veloppement
//   credentials: true,
//   methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
//   allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
// }));

// // Middleware pour parser JSON
// app.use(express.json({ limit: '10mb' }));
// app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// // Middleware de logging pour debug
// app.use((req, res, next) => {
//   const timestamp = new Date().toISOString();
//   console.log(`${timestamp} - ${req.method} ${req.path}`);
  
//   if (req.headers.authorization) {
//     console.log('üîë Authorization header pr√©sent');
//   }
  
//   if (req.body && Object.keys(req.body).length > 0) {
//     console.log('üì¶ Body:', JSON.stringify(req.body, null, 2));
//   }
  
//   next();
// });

// // URL MongoDB - CHANGEZ CETTE URL SELON VOTRE CONFIGURATION
// const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/chatbot';

// // Connexion MongoDB
// const connectDB = async () => {
//   try {
//     // Essayer plusieurs configurations MongoDB
//     const mongoOptions = {
//       useNewUrlParser: true,
//       useUnifiedTopology: true,
//     };

//     console.log('üîÑ Tentative de connexion MongoDB...');
//     console.log('üìç URI:', MONGODB_URI);
    
//     await mongoose.connect(MONGODB_URI, mongoOptions);
//     console.log('‚úÖ MongoDB connect√© avec succ√®s');
//     console.log('üè¢ Base de donn√©es:', mongoose.connection.name);
    
//   } catch (error) {
//     console.error('‚ùå Erreur MongoDB:', error.message);
//     console.log('‚ö†Ô∏è Le serveur continuera sans MongoDB (mode d√©grad√©)');
//     // Ne pas arr√™ter le serveur
//   }
// };

// // Sch√©ma utilisateur MongoDB
// const userSchema = new mongoose.Schema({
//   uid: { type: String, required: true, unique: true },
//   firstname: { type: String, required: true },
//   lastname: { type: String, required: true },
//   birthdate: { type: String },
//   email: { type: String, required: true, unique: true },
//   registrationDate: { type: Date, default: Date.now },
//   lastLogin: { type: Date, default: Date.now }
// }, { timestamps: true });

// const User = mongoose.model('User', userSchema);

// // Middleware d'authentification Firebase (simplifi√©)
// const authenticateToken = async (req, res, next) => {
//   try {
//     const authHeader = req.headers.authorization;
//     if (authHeader && authHeader.startsWith('Bearer ')) {
//       const token = authHeader.substring(7);
//       console.log('üîê Token re√ßu:', token.substring(0, 20) + '...');
//       // Pour le moment, on fait confiance au token (√† am√©liorer avec Firebase Admin)
//       req.userToken = token;
//     }
//     next();
//   } catch (error) {
//     console.log('‚ö†Ô∏è Erreur token:', error.message);
//     next(); // Continuer m√™me sans token valide
//   }
// };

// // üè† ROUTES API

// // Route de test - TR√àS IMPORTANTE
// app.get('/', (req, res) => {
//   res.json({ 
//     message: 'API ChatBot Backend en ligne',
//     timestamp: new Date(),
//     status: 'running',
//     mongodb: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected'
//   });
// });

// // Route de test API
// app.get('/api', (req, res) => {
//   res.json({ 
//     message: 'API du ChatBot est en ligne', 
//     timestamp: new Date(),
//     cors: 'enabled',
//     mongodb: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
//     routes: [
//       'GET /api',
//       'POST /api/users/register', 
//       'GET /api/users/:uid',
//       'POST /api/users/login'
//     ]
//   });
// });

// // üìù Route d'inscription
// app.post('/api/users/register', authenticateToken, async (req, res) => {
//   try {
//     console.log('üìù === INSCRIPTION ===');
//     console.log('Donn√©es re√ßues:', req.body);
    
//     const { uid, firstname, lastname, birthdate, email } = req.body;
    
//     // Validation des donn√©es
//     if (!uid || !firstname || !lastname || !email) {
//       console.log('‚ùå Donn√©es manquantes');
//       return res.status(400).json({ 
//         error: 'Donn√©es manquantes',
//         required: ['uid', 'firstname', 'lastname', 'email'],
//         received: { 
//           uid: !!uid, 
//           firstname: !!firstname, 
//           lastname: !!lastname, 
//           email: !!email 
//         }
//       });
//     }

//     let savedUser = null;

//     // Si MongoDB est connect√©, sauvegarder en base
//     if (mongoose.connection.readyState === 1) {
//       try {
//         // V√©rifier si l'utilisateur existe d√©j√†
//         const existingUser = await User.findOne({ $or: [{ uid }, { email }] });
//         if (existingUser) {
//           console.log('‚ö†Ô∏è Utilisateur d√©j√† existant:', existingUser._id);
//           return res.status(200).json({ 
//             message: 'Utilisateur d√©j√† existant (pas d\'erreur)',
//             user: {
//               uid: existingUser.uid,
//               firstname: existingUser.firstname,
//               lastname: existingUser.lastname,
//               email: existingUser.email
//             }
//           });
//         }

//         // Cr√©er nouvel utilisateur
//         const newUser = new User({
//           uid,
//           firstname,
//           lastname,
//           birthdate,
//           email
//         });

//         savedUser = await newUser.save();
//         console.log('‚úÖ Utilisateur sauvegard√© en MongoDB:', savedUser._id);
        
//       } catch (dbError) {
//         console.error('‚ö†Ô∏è Erreur MongoDB:', dbError.message);
//         // Continuer m√™me si la base de donn√©es a un probl√®me
//       }
//     } else {
//       console.log('‚ö†Ô∏è MongoDB non connect√©, simulation de la sauvegarde');
//     }
    
//     console.log('‚úÖ Inscription r√©ussie pour:', uid);
//     res.status(201).json({ 
//       message: 'Utilisateur enregistr√© avec succ√®s',
//       user: {
//         uid,
//         firstname,
//         lastname,
//         email,
//         registrationDate: savedUser?.registrationDate || new Date()
//       },
//       mongodb: mongoose.connection.readyState === 1
//     });

//   } catch (error) {
//     console.error('‚ùå Erreur lors de l\'enregistrement:', error);
//     res.status(500).json({ 
//       error: 'Erreur interne du serveur',
//       details: error.message 
//     });
//   }
// });

// // üîç Route pour r√©cup√©rer un utilisateur par UID
// app.get('/api/users/:uid', authenticateToken, async (req, res) => {
//   try {
//     console.log('üîç === R√âCUP√âRATION UTILISATEUR ===');
//     const { uid } = req.params;
//     console.log('UID recherch√©:', uid);
    
//     if (!uid) {
//       return res.status(400).json({ error: 'UID manquant' });
//     }

//     let user = null;

//     // Si MongoDB est connect√©, r√©cup√©rer depuis la base
//     if (mongoose.connection.readyState === 1) {
//       try {
//         user = await User.findOne({ uid });
//         console.log('üë§ Utilisateur trouv√© en base:', !!user);
        
//         if (user) {
//           // Mettre √† jour la derni√®re connexion
//           user.lastLogin = new Date();
//           await user.save();
//         }
//       } catch (dbError) {
//         console.error('‚ö†Ô∏è Erreur MongoDB:', dbError.message);
//       }
//     }

//     if (user) {
//       res.status(200).json({
//         message: 'Utilisateur trouv√©',
//         user: {
//           uid: user.uid,
//           firstname: user.firstname,
//           lastname: user.lastname,
//           email: user.email,
//           birthdate: user.birthdate,
//           registrationDate: user.registrationDate,
//           lastLogin: user.lastLogin
//         }
//       });
//     } else {
//       // Utilisateur pas trouv√© en base, retourner des donn√©es par d√©faut
//       console.log('‚ö†Ô∏è Utilisateur non trouv√© en base');
//       res.status(404).json({ 
//         error: 'Utilisateur non trouv√© en base de donn√©es',
//         suggestion: 'L\'utilisateur existe peut-√™tre seulement dans Firebase'
//       });
//     }

//   } catch (error) {
//     console.error('‚ùå Erreur lors de la r√©cup√©ration:', error);
//     res.status(500).json({ 
//       error: 'Erreur interne du serveur',
//       details: error.message 
//     });
//   }
// });

// // üîê Route de connexion (bonus)
// app.post('/api/users/login', authenticateToken, async (req, res) => {
//   try {
//     console.log('üîê === CONNEXION ===');
//     const { uid } = req.body;
    
//     if (!uid) {
//       return res.status(400).json({ error: 'UID manquant' });
//     }

//     if (mongoose.connection.readyState === 1) {
//       const user = await User.findOneAndUpdate(
//         { uid },
//         { lastLogin: new Date() },
//         { new: true }
//       );

//       if (user) {
//         console.log('‚úÖ Connexion enregistr√©e pour:', user.email);
//         return res.status(200).json({
//           message: 'Connexion r√©ussie',
//           user: {
//             uid: user.uid,
//             firstname: user.firstname,
//             lastname: user.lastname,
//             email: user.email
//           }
//         });
//       }
//     }

//     res.status(200).json({
//       message: 'Connexion accept√©e (mode d√©grad√©)',
//       uid
//     });

//   } catch (error) {
//     console.error('‚ùå Erreur lors de la connexion:', error);
//     res.status(500).json({ error: 'Erreur interne du serveur' });
//   }
// });

// // Route OPTIONS pour CORS
// app.options('*', (req, res) => {
//   res.header('Access-Control-Allow-Origin', '*');
//   res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
//   res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-Requested-With');
//   res.sendStatus(200);
// });

// // Servir les fichiers statiques du frontend
// app.use(express.static(path.join(__dirname, '../chatbot')));

// // Route catch-all pour le frontend
// app.get('*', (req, res) => {
//   // Si c'est une route API, retourner 404
//   if (req.path.startsWith('/api/')) {
//     return res.status(404).json({ error: 'Route API non trouv√©e' });
//   }
  
//   // Sinon, servir le frontend
//   res.sendFile(path.join(__dirname, '../chatbot/Ai-connexion.html'));
// });

// // Gestion des erreurs globales
// app.use((error, req, res, next) => {
//   console.error('‚ùå Erreur globale:', error);
//   res.status(500).json({ 
//     error: 'Erreur interne du serveur',
//     message: error.message
//   });
// });

// // üöÄ D√©marrage du serveur
// const startServer = async () => {
//   try {
//     // Tenter de se connecter √† MongoDB
//     await connectDB();
    
//     app.listen(PORT, '0.0.0.0', () => {
//       console.log('\nüéâ ================================');
//       console.log('üöÄ SERVEUR BACKEND D√âMARR√â !');
//       console.log('================================');
//       console.log(`üìç URL: http://localhost:${PORT}`);
//       console.log(`üîó API: http://localhost:${PORT}/api`);
//       console.log(`üåê CORS: Activ√© (toutes origines)`);
//       console.log(`üóÉÔ∏è  MongoDB: ${mongoose.connection.readyState === 1 ? 'Connect√©' : 'Mode d√©grad√©'}`);
//       console.log('================================\n');
      
//       console.log('üìã Routes disponibles:');
//       console.log('  GET  / (page d\'accueil)');
//       console.log('  GET  /api (test API)');
//       console.log('  POST /api/users/register');
//       console.log('  GET  /api/users/:uid');
//       console.log('  POST /api/users/login');
//       console.log('\nüîß Pr√™t √† recevoir les requ√™tes !');
//     });
//   } catch (error) {
//     console.error('‚ùå Erreur critique au d√©marrage:', error);
//     process.exit(1);
//   }
// };


// // Import des services
// const aiService = require('./services/aiService');
// const recommendationService = require('./services/recommendationService');

// // ü§ñ Route pour les r√©ponses IA (invit√©s et utilisateurs connect√©s)
// app.post('/api/guest-response', async (req, res) => {
//   try {
//     console.log('ü§ñ === REQU√äTE IA ===');
//     console.log('Message re√ßu:', req.body.message);
    
//     const { message, conversationHistory = [] } = req.body;
    
//     if (!message || !message.trim()) {
//       return res.status(400).json({ 
//         error: 'Message requis',
//         message: 'Veuillez fournir un message √† traiter'
//       });
//     }

//     // R√©cup√©rer le profil utilisateur si connect√©
//     let userProfile = null;
//     const authHeader = req.headers.authorization;
//     if (authHeader && authHeader.startsWith('Bearer ')) {
//       try {
//         const token = authHeader.substring(7);
//         // Ici vous pourriez d√©coder le token pour r√©cup√©rer l'utilisateur
//         // Pour l'instant, on continue sans profil sp√©cifique
//         console.log('üîê Utilisateur authentifi√© d√©tect√©');
//       } catch (tokenError) {
//         console.log('‚ö†Ô∏è Token invalide, continuons en mode invit√©');
//       }
//     }

//     console.log('üß† Envoi vers OpenAI...');
    
//     // Appel au service IA
//     const aiResult = await aiService.generateResponse(
//       message.trim(), 
//       conversationHistory, 
//       userProfile
//     );
    
//     if (aiResult.success) {
//       console.log('‚úÖ R√©ponse IA g√©n√©r√©e avec succ√®s');
//       console.log('üìä Tokens utilis√©s:', aiResult.usage?.total_tokens || 'N/A');
      
//       res.json({ 
//         text: aiResult.response,
//         usage: aiResult.usage,
//         timestamp: new Date().toISOString()
//       });
//     } else {
//       console.error('‚ùå Erreur du service IA:', aiResult.error);
//       res.status(500).json({ 
//         error: 'Erreur du service IA',
//         message: aiResult.error,
//         details: aiResult.details
//       });
//     }
    
//   } catch (error) {
//     console.error('‚ùå Erreur dans guest-response:', error);
//     res.status(500).json({ 
//       error: 'Erreur interne du serveur',
//       message: error.message,
//       suggestion: 'V√©rifiez votre cl√© API OpenAI et votre connexion internet'
//     });
//   }
// });

// // üìö Route pour la recherche de cours
// app.get('/api/courses/search', async (req, res) => {
//   try {
//     console.log('üìö === RECHERCHE COURS ===');
//     const { query, category, level, limit = 5 } = req.query;
    
//     if (mongoose.connection.readyState !== 1) {
//       return res.status(503).json({
//         error: 'Base de donn√©es non disponible',
//         message: 'Le service de cours n√©cessite une connexion √† la base de donn√©es'
//       });
//     }

//     // Importer le mod√®le Course
//     const Course = require('./models/course');
    
//     let searchQuery = {};
    
//     if (query) {
//       searchQuery.$or = [
//         { title: { $regex: query, $options: 'i' } },
//         { description: { $regex: query, $options: 'i' } },
//         { skills: { $in: [new RegExp(query, 'i')] } }
//       ];
//     }
    
//     if (category) {
//       searchQuery.category = category;
//     }
    
//     if (level) {
//       searchQuery.level = level;
//     }

//     const courses = await Course.find(searchQuery)
//       .sort({ rating: -1, enrolledCount: -1 })
//       .limit(parseInt(limit));

//     console.log(`‚úÖ ${courses.length} cours trouv√©s`);
    
//     res.json({
//       courses: courses,
//       total: courses.length,
//       query: { query, category, level, limit }
//     });
    
//   } catch (error) {
//     console.error('‚ùå Erreur recherche cours:', error);
//     res.status(500).json({ 
//       error: 'Erreur lors de la recherche de cours',
//       message: error.message 
//     });
//   }
// });

// // üìö Route pour les cours par cat√©gorie
// app.get('/api/courses/category/:category', async (req, res) => {
//   try {
//     console.log('üìö === COURS PAR CAT√âGORIE ===');
//     const { category } = req.params;
//     const { level, limit = 5 } = req.query;
    
//     if (mongoose.connection.readyState !== 1) {
//       return res.status(503).json({
//         error: 'Base de donn√©es non disponible'
//       });
//     }

//     const Course = require('./models/course');
    
//     let query = { category: decodeURIComponent(category) };
    
//     if (level) {
//       query.level = level;
//     }

//     const courses = await Course.find(query)
//       .sort({ rating: -1, enrolledCount: -1 })
//       .limit(parseInt(limit));

//     console.log(`‚úÖ ${courses.length} cours trouv√©s pour ${category}`);
    
//     res.json({
//       courses: courses,
//       category: category,
//       total: courses.length
//     });
    
//   } catch (error) {
//     console.error('‚ùå Erreur cours par cat√©gorie:', error);
//     res.status(500).json({ 
//       error: 'Erreur lors de la r√©cup√©ration des cours',
//       message: error.message 
//     });
//   }
// });

// // üéØ Route pour les recommandations personnalis√©es
// app.get('/api/recommendations', async (req, res) => {
//   try {
//     console.log('üéØ === RECOMMANDATIONS ===');
//     const { userId, limit = 3 } = req.query;
    
//     let recommendations;
    
//     if (userId && mongoose.connection.readyState === 1) {
//       // Recommandations personnalis√©es
//       recommendations = await recommendationService.getPersonalizedRecommendations(
//         userId, 
//         parseInt(limit)
//       );
//     } else {
//       // Cours populaires par d√©faut
//       recommendations = await recommendationService.getPopularCourses(parseInt(limit));
//     }
    
//     console.log(`‚úÖ ${recommendations.length} recommandations g√©n√©r√©es`);
    
//     res.json({
//       recommendations: recommendations,
//       personalized: !!userId,
//       total: recommendations.length
//     });
    
//   } catch (error) {
//     console.error('‚ùå Erreur recommandations:', error);
//     res.status(500).json({ 
//       error: 'Erreur lors de la g√©n√©ration des recommandations',
//       message: error.message 
//     });
//   }
// });

// console.log('‚úÖ Routes IA et cours ajout√©es au serveur');

// startServer();

// server.js - Version mise √† jour avec gestion des conversations
const express = require('express');
const cors = require('cors');
const mongoose = require('mongoose');
const dotenv = require('dotenv');
const path = require('path');

// Chargement des variables d'environnement
dotenv.config();

const app = express();
const PORT = process.env.PORT || 5000;

// ‚ö†Ô∏è CORS DOIT √äTRE CONFIGUR√â EN PREMIER
app.use(cors({
  origin: '*', // Accepter toutes les origines pour le d√©veloppement
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'X-User-ID']
}));

// Middleware pour parser JSON
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Middleware de logging pour debug
app.use((req, res, next) => {
  const timestamp = new Date().toISOString();
  console.log(`${timestamp} - ${req.method} ${req.path}`);
  
  if (req.headers.authorization) {
    console.log('üîë Authorization header pr√©sent');
  }
  
  if (req.headers['x-user-id']) {
    console.log('üë§ X-User-ID header:', req.headers['x-user-id']);
  }
  
  if (req.body && Object.keys(req.body).length > 0) {
    console.log('üì¶ Body:', JSON.stringify(req.body, null, 2));
  }
  
  next();
});

// URL MongoDB - CHANGEZ CETTE URL SELON VOTRE CONFIGURATION
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/chatbot';

// Connexion MongoDB
const connectDB = async () => {
  try {
    const mongoOptions = {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    };

    console.log('üîÑ Tentative de connexion MongoDB...');
    console.log('üìç URI:', MONGODB_URI);
    
    await mongoose.connect(MONGODB_URI, mongoOptions);
    console.log('‚úÖ MongoDB connect√© avec succ√®s');
    console.log('üè¢ Base de donn√©es:', mongoose.connection.name);
    
  } catch (error) {
    console.error('‚ùå Erreur MongoDB:', error.message);
    console.log('‚ö†Ô∏è Le serveur continuera sans MongoDB (mode d√©grad√©)');
  }
};

// Sch√©mas MongoDB
const userSchema = new mongoose.Schema({
  uid: { type: String, required: true, unique: true },
  firstname: { type: String, required: true },
  lastname: { type: String, required: true },
  birthdate: { type: String },
  email: { type: String, required: true, unique: true },
  registrationDate: { type: Date, default: Date.now },
  lastLogin: { type: Date, default: Date.now }
}, { timestamps: true });

// ‚≠ê NOUVEAU : Sch√©ma Conversation
const conversationSchema = new mongoose.Schema({
  title: {
    type: String,
    default: 'Nouvelle conversation'
  },
  userId: {
    type: String, // On utilise String pour l'UID Firebase
    required: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  lastUpdated: {
    type: Date,
    default: Date.now
  }
});

// ‚≠ê NOUVEAU : Sch√©ma Message
const messageSchema = new mongoose.Schema({
  text: {
    type: String,
    required: true
  },
  sender: {
    type: String,
    enum: ['user', 'bot'],
    required: true
  },
  conversationId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Conversation',
    required: true
  },
  timestamp: {
    type: Date,
    default: Date.now
  },
  metadata: {
    type: mongoose.Schema.Types.Mixed,
    default: {}
  }
});

const User = mongoose.model('User', userSchema);
const Conversation = mongoose.model('Conversation', conversationSchema);
const Message = mongoose.model('Message', messageSchema);

// Middleware d'authentification Firebase (simplifi√©)
const authenticateToken = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      const token = authHeader.substring(7);
      console.log('üîê Token re√ßu:', token.substring(0, 20) + '...');
      req.userToken = token;
    }
    next();
  } catch (error) {
    console.log('‚ö†Ô∏è Erreur token:', error.message);
    next();
  }
};

// Middleware pour extraire l'userId
// Dans server.js, m√©thode extractUserId
const extractUserId = (req, res, next) => {
    let userId = null;

    // 1. Depuis les headers personnalis√©s
    if (req.headers['x-user-id']) {
        userId = req.headers['x-user-id'];
        console.log('üë§ UserId depuis header X-User-ID:', userId);
    }
    // 2. Depuis le body
    else if (req.body && req.body.userId) {
        userId = req.body.userId;
        console.log('üë§ UserId depuis body:', userId);
    }

    req.extractedUserId = userId;
    
    if (userId) {
        console.log('‚úÖ UserId extrait avec succ√®s:', userId);
    } else {
        console.log('‚ùå Aucun userId trouv√©');
    }

    next();
};

// üè† ROUTES API EXISTANTES

app.get('/', (req, res) => {
  res.json({ 
    message: 'API ChatBot Backend en ligne',
    timestamp: new Date(),
    status: 'running',
    mongodb: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected'
  });
});

app.get('/api', (req, res) => {
  res.json({ 
    message: 'API du ChatBot est en ligne', 
    timestamp: new Date(),
    cors: 'enabled',
    mongodb: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
    routes: [
      'GET /api',
      'POST /api/users/register', 
      'GET /api/users/:uid',
      'POST /api/users/login',
      'POST /api/guest-response',
      'GET /api/conversations',
      'POST /api/conversations',
      'DELETE /api/conversations/:id',
      'GET /api/conversations/:id/messages'
    ]
  });
});

// Vos routes existantes (register, login, etc.)
app.post('/api/users/register', authenticateToken, async (req, res) => {
  try {
    console.log('üìù === INSCRIPTION ===');
    console.log('Donn√©es re√ßues:', req.body);
    
    const { uid, firstname, lastname, birthdate, email } = req.body;
    
    if (!uid || !firstname || !lastname || !email) {
      console.log('‚ùå Donn√©es manquantes');
      return res.status(400).json({ 
        error: 'Donn√©es manquantes',
        required: ['uid', 'firstname', 'lastname', 'email'],
        received: { 
          uid: !!uid, 
          firstname: !!firstname, 
          lastname: !!lastname, 
          email: !!email 
        }
      });
    }

    let savedUser = null;

    if (mongoose.connection.readyState === 1) {
      try {
        const existingUser = await User.findOne({ $or: [{ uid }, { email }] });
        if (existingUser) {
          console.log('‚ö†Ô∏è Utilisateur d√©j√† existant:', existingUser._id);
          return res.status(200).json({ 
            message: 'Utilisateur d√©j√† existant (pas d\'erreur)',
            user: {
              uid: existingUser.uid,
              firstname: existingUser.firstname,
              lastname: existingUser.lastname,
              email: existingUser.email
            }
          });
        }

        const newUser = new User({
          uid,
          firstname,
          lastname,
          birthdate,
          email
        });

        savedUser = await newUser.save();
        console.log('‚úÖ Utilisateur sauvegard√© en MongoDB:', savedUser._id);
        
      } catch (dbError) {
        console.error('‚ö†Ô∏è Erreur MongoDB:', dbError.message);
      }
    } else {
      console.log('‚ö†Ô∏è MongoDB non connect√©, simulation de la sauvegarde');
    }
    
    console.log('‚úÖ Inscription r√©ussie pour:', uid);
    res.status(201).json({ 
      message: 'Utilisateur enregistr√© avec succ√®s',
      user: {
        uid,
        firstname,
        lastname,
        email,
        registrationDate: savedUser?.registrationDate || new Date()
      },
      mongodb: mongoose.connection.readyState === 1
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de l\'enregistrement:', error);
    res.status(500).json({ 
      error: 'Erreur interne du serveur',
      details: error.message 
    });
  }
});

app.get('/api/users/:uid', authenticateToken, async (req, res) => {
  try {
    console.log('üîç === R√âCUP√âRATION UTILISATEUR ===');
    const { uid } = req.params;
    console.log('UID recherch√©:', uid);
    
    if (!uid) {
      return res.status(400).json({ error: 'UID manquant' });
    }

    let user = null;

    if (mongoose.connection.readyState === 1) {
      try {
        user = await User.findOne({ uid });
        console.log('üë§ Utilisateur trouv√© en base:', !!user);
        
        if (user) {
          user.lastLogin = new Date();
          await user.save();
        }
      } catch (dbError) {
        console.error('‚ö†Ô∏è Erreur MongoDB:', dbError.message);
      }
    }

    if (user) {
      res.status(200).json({
        message: 'Utilisateur trouv√©',
        user: {
          uid: user.uid,
          firstname: user.firstname,
          lastname: user.lastname,
          email: user.email,
          birthdate: user.birthdate,
          registrationDate: user.registrationDate,
          lastLogin: user.lastLogin
        }
      });
    } else {
      console.log('‚ö†Ô∏è Utilisateur non trouv√© en base');
      res.status(404).json({ 
        error: 'Utilisateur non trouv√© en base de donn√©es',
        suggestion: 'L\'utilisateur existe peut-√™tre seulement dans Firebase'
      });
    }

  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration:', error);
    res.status(500).json({ 
      error: 'Erreur interne du serveur',
      details: error.message 
    });
  }
});

app.post('/api/users/login', authenticateToken, async (req, res) => {
  try {
    console.log('üîê === CONNEXION ===');
    const { uid } = req.body;
    
    if (!uid) {
      return res.status(400).json({ error: 'UID manquant' });
    }

    if (mongoose.connection.readyState === 1) {
      const user = await User.findOneAndUpdate(
        { uid },
        { lastLogin: new Date() },
        { new: true }
      );

      if (user) {
        console.log('‚úÖ Connexion enregistr√©e pour:', user.email);
        return res.status(200).json({
          message: 'Connexion r√©ussie',
          user: {
            uid: user.uid,
            firstname: user.firstname,
            lastname: user.lastname,
            email: user.email
          }
        });
      }
    }

    res.status(200).json({
      message: 'Connexion accept√©e (mode d√©grad√©)',
      uid
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de la connexion:', error);
    res.status(500).json({ error: 'Erreur interne du serveur' });
  }
});

// ‚≠ê NOUVELLES ROUTES CONVERSATIONS

// Fonction utilitaire pour g√©n√©rer un titre de conversation intelligent
function generateConversationTitle(message) {
  const cleanMessage = message.trim().toLowerCase();
  
  const keywords = {
    'd√©veloppement': 'Apprentissage D√©veloppement',
    'd√©veloppeur': 'Devenir D√©veloppeur',
    'web': 'D√©veloppement Web',
    'javascript': 'Formation JavaScript',
    'react': 'Formation React',
    'python': 'Formation Python',
    'cybers√©curit√©': 'Formation Cybers√©curit√©',
    'design': 'Formation Design',
    'formation': 'Recherche Formation',
    'cours': 'Recherche Cours',
    'apprendre': 'Apprentissage'
  };
  
  for (const [keyword, title] of Object.entries(keywords)) {
    if (cleanMessage.includes(keyword)) {
      return title;
    }
  }
  
  const truncated = message.substring(0, 50);
  return truncated.length < message.length ? truncated + '...' : truncated;
}

// Route pour cr√©er une conversation
app.post('/api/conversations', extractUserId, async (req, res) => {
  try {
    console.log('üÜï === CR√âATION CONVERSATION ===');
    const { title } = req.body;
    const userId = req.extractedUserId;
    
    if (!userId) {
      return res.status(401).json({ 
        error: 'Utilisateur non authentifi√©',
        success: false
      });
    }

    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({ 
        error: 'Base de donn√©es non disponible',
        success: false
      });
    }

    const conversation = new Conversation({
      title: title || 'Nouvelle conversation',
      userId: userId,
      createdAt: new Date(),
      lastUpdated: new Date()
    });

    const savedConversation = await conversation.save();
    console.log('‚úÖ Conversation cr√©√©e:', savedConversation._id);

    res.status(201).json({
      conversation: savedConversation,
      success: true
    });

  } catch (error) {
    console.error('‚ùå Erreur cr√©ation conversation:', error);
    res.status(500).json({ 
      error: 'Erreur serveur',
      success: false
    });
  }
});

// Route pour r√©cup√©rer les conversations d'un utilisateur
app.get('/api/conversations', extractUserId, async (req, res) => {
  try {
    console.log('üìö === R√âCUP√âRATION CONVERSATIONS ===');
    const userId = req.extractedUserId;
    
    if (!userId) {
      return res.status(401).json({ 
        error: 'Utilisateur non authentifi√©',
        conversations: []
      });
    }

    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({ 
        error: 'Base de donn√©es non disponible',
        conversations: []
      });
    }

    const conversations = await Conversation.find({ userId })
      .sort({ lastUpdated: -1 })
      .limit(50)
      .select('title createdAt lastUpdated');

    console.log(`‚úÖ ${conversations.length} conversations trouv√©es`);

    res.json({ 
      conversations,
      total: conversations.length,
      success: true
    });

  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration conversations:', error);
    res.status(500).json({ 
      error: 'Erreur serveur',
      conversations: [],
      success: false
    });
  }
});

// Route pour r√©cup√©rer les messages d'une conversation
app.get('/api/conversations/:conversationId/messages', extractUserId, async (req, res) => {
  try {
    console.log('üí¨ === R√âCUP√âRATION MESSAGES ===');
    const { conversationId } = req.params;
    const userId = req.extractedUserId;
    
    if (!userId) {
      return res.status(401).json({ 
        error: 'Utilisateur non authentifi√©',
        messages: []
      });
    }

    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({ 
        error: 'Base de donn√©es non disponible',
        messages: []
      });
    }

    // V√©rifier que la conversation appartient √† l'utilisateur
    const conversation = await Conversation.findOne({ 
      _id: conversationId, 
      userId 
    });
    
    if (!conversation) {
      return res.status(404).json({ 
        error: 'Conversation non trouv√©e',
        messages: []
      });
    }

    const messages = await Message.find({ conversationId })
      .sort({ timestamp: 1 })
      .select('text sender timestamp metadata');

    console.log(`‚úÖ ${messages.length} messages r√©cup√©r√©s`);

    res.json({ 
      messages,
      conversation: {
        id: conversation._id,
        title: conversation.title,
        createdAt: conversation.createdAt,
        lastUpdated: conversation.lastUpdated
      },
      total: messages.length,
      success: true
    });

  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration messages:', error);
    res.status(500).json({ 
      error: 'Erreur serveur',
      messages: [],
      success: false
    });
  }
});

// Route pour supprimer une conversation
app.delete('/api/conversations/:conversationId', extractUserId, async (req, res) => {
  try {
    console.log('üóëÔ∏è === SUPPRESSION CONVERSATION ===');
    const { conversationId } = req.params;
    const userId = req.extractedUserId;
    
    if (!userId) {
      return res.status(401).json({ 
        error: 'Utilisateur non authentifi√©',
        success: false
      });
    }

    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({ 
        error: 'Base de donn√©es non disponible',
        success: false
      });
    }

    // V√©rifier que la conversation appartient √† l'utilisateur
    const conversation = await Conversation.findOne({ 
      _id: conversationId, 
      userId 
    });
    
    if (!conversation) {
      return res.status(404).json({ 
        error: 'Conversation non trouv√©e',
        success: false
      });
    }

    // Supprimer tous les messages de la conversation
    await Message.deleteMany({ conversationId });
    
    // Supprimer la conversation
    await Conversation.findByIdAndDelete(conversationId);

    console.log('‚úÖ Conversation supprim√©e:', conversationId);

    res.json({ 
      message: 'Conversation supprim√©e avec succ√®s',
      deletedConversationId: conversationId,
      success: true
    });

  } catch (error) {
    console.error('‚ùå Erreur suppression conversation:', error);
    res.status(500).json({ 
      error: 'Erreur serveur',
      success: false
    });
  }
});

// Import des services
const aiService = require('./services/aiService');
const recommendationService = require('./services/recommendationService');

// ü§ñ Route pour les r√©ponses IA MISE √Ä JOUR avec sauvegarde
app.post('/api/guest-response', extractUserId, async (req, res) => {
  try {
    console.log('ü§ñ === REQU√äTE IA AVEC SAUVEGARDE ===');
    console.log('Message re√ßu:', req.body.message);
    
    const { message, conversationHistory = [], conversationId } = req.body;
    const userId = req.extractedUserId;
    
    if (!message || !message.trim()) {
      return res.status(400).json({ 
        error: 'Message requis',
        message: 'Veuillez fournir un message √† traiter',
        success: false
      });
    }

    // 1. G√âRER LA CONVERSATION
    let currentConversationId = conversationId;
    let conversationCreated = false;
    
    if (mongoose.connection.readyState === 1) {
      try {
        // Si pas de conversationId et utilisateur connect√©, cr√©er une nouvelle conversation
        if (!currentConversationId && userId) {
          console.log('üÜï Cr√©ation d\'une nouvelle conversation...');
          
          const title = generateConversationTitle(message);
          
          const newConversation = new Conversation({
            userId: userId,
            title: title,
            createdAt: new Date(),
            lastUpdated: new Date()
          });
          
          const savedConversation = await newConversation.save();
          currentConversationId = savedConversation._id;
          conversationCreated = true;
          
          console.log('‚úÖ Nouvelle conversation cr√©√©e:', currentConversationId);
        }

        // V√©rifier que la conversation existe et appartient √† l'utilisateur
        if (currentConversationId && userId) {
          const existingConversation = await Conversation.findOne({
            _id: currentConversationId,
            userId: userId
          });
          
          if (!existingConversation) {
            console.log('‚ö†Ô∏è Conversation non trouv√©e ou acc√®s non autoris√©');
            currentConversationId = null;
          }
        }

        // Sauvegarder le message utilisateur
        if (currentConversationId) {
          const userMessage = new Message({
            text: message.trim(),
            sender: 'user',
            conversationId: currentConversationId,
            timestamp: new Date(),
            metadata: {
              userAgent: req.headers['user-agent'],
              ip: req.ip || req.connection.remoteAddress
            }
          });
          
          await userMessage.save();
          console.log('üí¨ Message utilisateur sauvegard√©');
          
          // Mettre √† jour la conversation
          await Conversation.findByIdAndUpdate(currentConversationId, {
            lastUpdated: new Date()
          });
        }
        
      } catch (dbError) {
        console.error('‚ö†Ô∏è Erreur base de donn√©es (message utilisateur):', dbError.message);
      }
    }

    console.log('üß† Envoi vers le service IA...');
    
    // 2. APPEL AU SERVICE IA
    const aiResult = await aiService.generateResponse(
      message.trim(), 
      conversationHistory, 
      null // userProfile
    );
    
    if (aiResult.success) {
      console.log('‚úÖ R√©ponse IA g√©n√©r√©e avec succ√®s');
      console.log('üìä Tokens utilis√©s:', aiResult.usage?.total_tokens || 'N/A');
      
      // 3. SAUVEGARDER LA R√âPONSE IA
      if (mongoose.connection.readyState === 1 && currentConversationId) {
        try {
          const botMessage = new Message({
            text: aiResult.response,
            sender: 'bot',
            conversationId: currentConversationId,
            timestamp: new Date(),
            metadata: {
              tokensUsed: aiResult.usage?.total_tokens,
              model: 'gpt-3.5-turbo'
            }
          });
          
          await botMessage.save();
          console.log('ü§ñ R√©ponse IA sauvegard√©e');

          // Mettre √† jour la conversation
          await Conversation.findByIdAndUpdate(currentConversationId, {
            lastUpdated: new Date()
          });
          
        } catch (dbError) {
          console.error('‚ö†Ô∏è Erreur sauvegarde r√©ponse IA:', dbError.message);
        }
      }
      
      // 4. R√âPONSE AU CLIENT
      res.json({ 
        text: aiResult.response,
        conversationId: currentConversationId,
        conversationCreated: conversationCreated,
        usage: aiResult.usage,
        timestamp: new Date().toISOString(),
        success: true
      });
      
    } else {
      console.error('‚ùå Erreur du service IA:', aiResult.error);
      res.status(500).json({ 
        error: 'Erreur du service IA',
        message: aiResult.error,
        details: aiResult.details,
        success: false
      });
    }
    
  } catch (error) {
    console.error('‚ùå Erreur dans guest-response:', error);
    res.status(500).json({ 
      error: 'Erreur interne du serveur',
      message: error.message,
      success: false
    });
  }
});

// Vos autres routes existantes (courses, etc.)
app.get('/api/courses/search', async (req, res) => {
  try {
    console.log('üìö === RECHERCHE COURS ===');
    const { query, category, level, limit = 5 } = req.query;
    
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        error: 'Base de donn√©es non disponible',
        message: 'Le service de cours n√©cessite une connexion √† la base de donn√©es'
      });
    }

    const Course = require('./models/course');
    
    let searchQuery = {};
    
    if (query) {
      searchQuery.$or = [
        { title: { $regex: query, $options: 'i' } },
        { description: { $regex: query, $options: 'i' } },
        { skills: { $in: [new RegExp(query, 'i')] } }
      ];
    }
    
    if (category) {
      searchQuery.category = category;
    }
    
    if (level) {
      searchQuery.level = level;
    }

    const courses = await Course.find(searchQuery)
      .sort({ rating: -1, enrolledCount: -1 })
      .limit(parseInt(limit));

    console.log(`‚úÖ ${courses.length} cours trouv√©s`);
    
    res.json({
      courses: courses,
      total: courses.length,
      query: { query, category, level, limit }
    });
    
  } catch (error) {
    console.error('‚ùå Erreur recherche cours:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la recherche de cours',
      message: error.message 
    });
  }
});

app.get('/api/courses/category/:category', async (req, res) => {
  try {
    console.log('üìö === COURS PAR CAT√âGORIE ===');
    const { category } = req.params;
    const { level, limit = 5 } = req.query;
    
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        error: 'Base de donn√©es non disponible'
      });
    }

    const Course = require('./models/course');
    
    let query = { category: decodeURIComponent(category) };
    
    if (level) {
      query.level = level;
    }

    const courses = await Course.find(query)
      .sort({ rating: -1, enrolledCount: -1 })
      .limit(parseInt(limit));

    console.log(`‚úÖ ${courses.length} cours trouv√©s pour ${category}`);
    
    res.json({
      courses: courses,
      category: category,
      total: courses.length
    });
    
  } catch (error) {
    console.error('‚ùå Erreur cours par cat√©gorie:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la r√©cup√©ration des cours',
      message: error.message 
    });
  }
});

app.get('/api/recommendations', async (req, res) => {
  try {
    console.log('üéØ === RECOMMANDATIONS ===');
    const { userId, limit = 3 } = req.query;
    
    let recommendations;
    
    if (userId && mongoose.connection.readyState === 1) {
      recommendations = await recommendationService.getPersonalizedRecommendations(
        userId, 
        parseInt(limit)
      );
    } else {
      recommendations = await recommendationService.getPopularCourses(parseInt(limit));
    }
    
    console.log(`‚úÖ ${recommendations.length} recommandations g√©n√©r√©es`);
    
    res.json({
      recommendations: recommendations,
      personalized: !!userId,
      total: recommendations.length
    });
    
  } catch (error) {
    console.error('‚ùå Erreur recommandations:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la g√©n√©ration des recommandations',
      message: error.message 
    });
  }
});

// Route de sant√© pour tester les nouvelles fonctionnalit√©s
app.get('/api/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    mongodb: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
    service: 'ChatBot API',
    features: {
      conversations: true,
      messages: true,
      ai_responses: true,
      course_search: true,
      recommendations: true
    },
    version: '2.0.0'
  });
});

// Route OPTIONS pour CORS
app.options('*', (req, res) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-Requested-With,X-User-ID');
  res.sendStatus(200);
});

// Servir les fichiers statiques du frontend
app.use(express.static(path.join(__dirname, '../chatbot')));

// Route catch-all pour le frontend
app.get('*', (req, res) => {
  if (req.path.startsWith('/api/')) {
    return res.status(404).json({ 
      error: 'Route API non trouv√©e',
      availableRoutes: [
        'GET /api',
        'POST /api/users/register',
        'GET /api/users/:uid',
        'POST /api/users/login',
        'POST /api/guest-response',
        'GET /api/conversations',
        'POST /api/conversations',
        'DELETE /api/conversations/:id',
        'GET /api/conversations/:id/messages',
        'GET /api/courses/search',
        'GET /api/courses/category/:category',
        'GET /api/recommendations',
        'GET /api/health'
      ]
    });
  }
  
  // Sinon, servir le frontend
  res.sendFile(path.join(__dirname, '../chatbot/Ai-connexion.html'));
});

// Gestion des erreurs globales
app.use((error, req, res, next) => {
  console.error('‚ùå Erreur globale:', error);
  res.status(500).json({ 
    error: 'Erreur interne du serveur',
    message: error.message
  });
});

// üöÄ D√©marrage du serveur
const startServer = async () => {
  try {
    // Tenter de se connecter √† MongoDB
    await connectDB();
    
    app.listen(PORT, '0.0.0.0', () => {
      console.log('\nüéâ ================================');
      console.log('üöÄ SERVEUR BACKEND D√âMARR√â !');
      console.log('================================');
      console.log(`üìç URL: http://localhost:${PORT}`);
      console.log(`üîó API: http://localhost:${PORT}/api`);
      console.log(`üåê CORS: Activ√© (toutes origines)`);
      console.log(`üóÉÔ∏è  MongoDB: ${mongoose.connection.readyState === 1 ? 'Connect√©' : 'Mode d√©grad√©'}`);
      console.log('================================\n');
      
      console.log('üìã Routes disponibles:');
      console.log('  GET  / (page d\'accueil)');
      console.log('  GET  /api (test API)');
      console.log('  POST /api/users/register');
      console.log('  GET  /api/users/:uid');
      console.log('  POST /api/users/login');
      console.log('  POST /api/guest-response');
      console.log('  GET  /api/conversations');
      console.log('  POST /api/conversations');
      console.log('  DELETE /api/conversations/:id');
      console.log('  GET  /api/conversations/:id/messages');
      console.log('  GET  /api/courses/search');
      console.log('  GET  /api/courses/category/:category');
      console.log('  GET  /api/recommendations');
      console.log('  GET  /api/health');
      console.log('\nüîß Pr√™t √† recevoir les requ√™tes !');
      console.log('üíæ Sauvegarde des conversations: Activ√©e');
      console.log('ü§ñ IA avec persistance: Activ√©e');
    });
  } catch (error) {
    console.error('‚ùå Erreur critique au d√©marrage:', error);
    process.exit(1);
  }
};

console.log('‚úÖ Routes IA et conversations ajout√©es au serveur');

startServer();